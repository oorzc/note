(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{872:function(t,s,a){"use strict";a.r(s);var n=a(5),p=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"回溯法原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回溯法原理"}},[t._v("#")]),t._v(" 回溯法原理")]),t._v(" "),a("p",[t._v("学习正则表达式，是需要懂点儿匹配原理的。")]),t._v(" "),a("p",[t._v("而研究匹配原理时，有两个字出现的频率比较高：“回溯”。")]),t._v(" "),a("p",[t._v("听起来挺高大上，事实上却是一个比较容易理解的概念。")]),t._v(" "),a("p",[t._v("因此，本章就简单扼要地说清楚回溯到底是什么东西。")]),t._v(" "),a("h2",{attrs:{id:"没有回溯的匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#没有回溯的匹配"}},[t._v("#")]),t._v(" 没有回溯的匹配")]),t._v(" "),a("p",[t._v("假设我们的正则是 /ab{1,3}c/，其可视化形式是：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://qiniu.sponges.cn/note/20200814144239.png",alt:""}})]),t._v(" "),a("p",[t._v('而当目标字符串是 "abbbc" 时，就没有所谓的“回溯”。其匹配过程是：')]),t._v(" "),a("p",[a("img",{attrs:{src:"http://qiniu.sponges.cn/note/20200814144305.png",alt:""}})]),t._v(" "),a("p",[t._v('其中子表达式 b{1,3} 表示 "b" 字符连续出现 1 到 3 次。')]),t._v(" "),a("h2",{attrs:{id:"有回溯的匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有回溯的匹配"}},[t._v("#")]),t._v(" 有回溯的匹配")]),t._v(" "),a("p",[t._v('如果目标字符串是"abbc"，中间就有回溯。')]),t._v(" "),a("p",[a("img",{attrs:{src:"http://qiniu.sponges.cn/note/20200814144339.png",alt:""}})]),t._v(" "),a("p",[t._v('图中第 5 步有红颜色，表示匹配不成功。此时 b{1,3} 已经匹配到了 2 个字符 "b"，准备尝试第三个时，\n结果发现接下来的字符是 "c"。那么就认为 b{1,3} 就已经匹配完毕。然后状态又回到之前的状态（即\n第 6 步与第 4 步一样），最后再用子表达式 c，去匹配字符 "c"。当然，此时整个表达式匹配成功了。')]),t._v(" "),a("p",[t._v("图中的第 6 步，就是“回溯”。")]),t._v(" "),a("p",[t._v("你可能对此没有感觉，这里我们再举一个例子。正则是：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://qiniu.sponges.cn/note/20200814144450.png",alt:""}})]),t._v(" "),a("p",[t._v('目标字符串是"abbbc"，匹配过程是：')]),t._v(" "),a("p",[a("img",{attrs:{src:"http://qiniu.sponges.cn/note/20200814144518.png",alt:""}})]),t._v(" "),a("p",[t._v('其中第 7 步和第 10 步是回溯。第 7 步与第 4 步一样，此时 b{1,3} 匹配了两个 "b"，而第 10 步与\n第 3 步一样，此时 b{1,3} 只匹配了一个 "b"，这也是 b{1,3} 的最终匹配结果。')]),t._v(" "),a("p",[t._v("这里再看一个清晰的回溯，正则是：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://qiniu.sponges.cn/note/20200814144559.png",alt:""}})]),t._v(" "),a("p",[t._v('目标字符串是："abc"de，匹配过程是：')]),t._v(" "),a("p",[a("img",{attrs:{src:"http://qiniu.sponges.cn/note/20200814144624.png",alt:""}})]),t._v(" "),a("p",[t._v("图中省略了尝试匹配双引号失败的过程。可以看出 .* 是非常影响效率的。")]),t._v(" "),a("p",[t._v('为了减少一些不必要的回溯，可以把正则修改为 /"[^"]*"/。')]),t._v(" "),a("h2",{attrs:{id:"常见的回溯形式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的回溯形式"}},[t._v("#")]),t._v(" 常见的回溯形式")]),t._v(" "),a("p",[t._v("正则表达式匹配字符串的这种方式，有个学名，叫回溯法。")]),t._v(" "),a("blockquote",[a("p",[t._v("回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发能再前进），再后退一步或若干步，从（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。")])]),t._v(" "),a("p",[t._v("本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中\n，可以看出，路走不通时，就会发生“回溯”\n。即，尝试匹配失败时，接下来的一步通常就是回溯。")]),t._v(" "),a("p",[t._v("道理，我们是懂了。那么 JavaScript 中正则表达式会产生回溯的地方都有哪些呢？")]),t._v(" "),a("h3",{attrs:{id:"贪婪量词"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#贪婪量词"}},[t._v("#")]),t._v(" 贪婪量词")]),t._v(" "),a("p",[t._v('之前的例子都是贪婪量词相关的。比如 b{1,3}，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝\n试。首先会尝试 "bbb"，然后再看整个正则是否能匹配。不能匹配时，吐出一个 "b"，即在 "bb" 的基础\n上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行呢？只能说明匹配失败了。')]),t._v(" "),a("p",[t._v("虽然局部匹配是贪婪的，但也要满足整体能正确匹配。否则，皮之不存，毛将焉附？")]),t._v(" "),a("p",[t._v("此时我们不禁会问，如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？")]),t._v(" "),a("p",[t._v("答案是，先下手为强！因为深度优先搜索。测试如下：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" string "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"12345"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" regex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(\\d{1,3})(\\d{1,3})/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// => ["12345", "123", "45", index: 0, input: "12345"]')]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v('其中，前面的 \\d{1,3} 匹配的是 "123"，后面的 \\d{1,3} 匹配的是 "45"。')]),t._v(" "),a("h3",{attrs:{id:"惰性量词"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#惰性量词"}},[t._v("#")]),t._v(" 惰性量词")]),t._v(" "),a("p",[t._v("惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配，比如：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" string "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"12345"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" regex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(\\d{1,3}?)(\\d{1,3})/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// => ["1234", "1", "234", index: 0, input: "12345"]')]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v('其中 \\d{1,3}? 只匹配到一个字符 "1"，而后面的 \\d{1,3} 匹配了 "234"。')]),t._v(" "),a("p",[t._v("虽然惰性量词不贪，但也会有回溯的现象。比如正则是：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://qiniu.sponges.cn/note/20200814144944.png",alt:""}})]),t._v(" "),a("p",[t._v('目标字符串是 "12345"，匹配过程是：')]),t._v(" "),a("p",[a("img",{attrs:{src:"http://qiniu.sponges.cn/note/20200814145014.png",alt:""}})]),t._v(" "),a("p",[t._v('知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后 \\d{1,3}? 匹配的字\n符是 "12"，是两个数字，而不是一个。')]),t._v(" "),a("h3",{attrs:{id:"分支结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支结构"}},[t._v("#")]),t._v(" 分支结构")]),t._v(" "),a("p",[t._v('我们知道分支也是惰性的，比如 /can|candy/，去匹配字符串 "candy"，得到的结果是 "can"，因为分支会\n一个一个尝试，如果前面的满足了，后面就不会再试验了。')]),t._v(" "),a("p",[t._v("分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分\n支。这种尝试也可以看成一种回溯。")]),t._v(" "),a("p",[t._v("比如正则：/^(?:can|candy)$/")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://qiniu.sponges.cn/note/20200814145121.png",alt:""}})]),t._v(" "),a("p",[t._v('目标字符串是 "candy"，匹配过程：')]),t._v(" "),a("p",[a("img",{attrs:{src:"http://qiniu.sponges.cn/note/20200814145147.png",alt:""}})]),t._v(" "),a("p",[t._v("上面第 5 步，虽然没有回到之前的状态，但仍然回到了分支结构，尝试下一种可能。所以，可以认为它是\n一种回溯的。")]),t._v(" "),a("h2",{attrs:{id:"本章小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本章小结"}},[t._v("#")]),t._v(" 本章小结")]),t._v(" "),a("p",[t._v("其实回溯法，很容易掌握的。")]),t._v(" "),a("p",[t._v("简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最\n后都试完后，发现整体匹配不成功。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。\n惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。\n分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。\n")])])]),a("p",[t._v("既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些 DFA 引擎, DFA 是“确定型有限自动\n机”的简写。")]),t._v(" "),a("p",[t._v("而 JavaScript 的正则引擎是 NFA，NFA 是“非确定型有限自动机”的简写。")]),t._v(" "),a("p",[t._v("大部分语言中的正则都是 NFA，为啥它这么流行呢？")]),t._v(" "),a("p",[t._v("答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。")])])}),[],!1,null,null,null);s.default=p.exports}}]);