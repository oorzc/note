(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{644:function(t,s,a){"use strict";a.r(s);var e=a(5),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_14-class的继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-class的继承"}},[t._v("#")]),t._v(" 14.Class的继承")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"基本用法-基本用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本用法-基本用法"}},[t._v("#")]),t._v(" 基本用法 {#基本用法}")]),t._v(" "),a("p",[t._v("Class之间可以通过"),a("code",[t._v("extends")]),t._v("关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ColorPoint")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Point")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 调用父类的constructor(x, y)")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("color "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" color"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("color "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("' '")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 调用父类的toString()")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br")])]),a("p",[t._v("子类必须在"),a("code",[t._v("constructor")]),t._v("方法中调用"),a("code",[t._v("super")]),t._v("方法，否则新建实例时会报错。这是因为子类没有自己的"),a("code",[t._v("this")]),t._v("对象，而是继承父类的"),a("code",[t._v("this")]),t._v("对象，然后对其进行加工。如果不调用"),a("code",[t._v("super")]),t._v("方法，子类就得不到"),a("code",[t._v("this")]),t._v("对象。")]),t._v(" "),a("h3",{attrs:{id:"类的prototype属性和-proto-属性-类的prototype属性和-proto-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的prototype属性和-proto-属性-类的prototype属性和-proto-属性"}},[t._v("#")]),t._v(" 类的prototype属性和__proto__属性 {#类的prototype属性和__proto__属性}")]),t._v(" "),a("p",[t._v("大多数浏览器的ES5实现之中，每一个对象都有"),a("code",[t._v("__proto__")]),t._v("属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和"),a("code",[t._v("__proto__")]),t._v("属性，因此同时存在两条继承链。")]),t._v(" "),a("p",[t._v("（1）子类的"),a("code",[t._v("__proto__")]),t._v("属性，表示构造函数的继承，总是指向父类。")]),t._v(" "),a("p",[t._v("（2）子类"),a("code",[t._v("prototype")]),t._v("属性的"),a("code",[t._v("__proto__")]),t._v("属性，表示方法的继承，总是指向父类的"),a("code",[t._v("prototype")]),t._v("属性。")]),t._v(" "),a("p",[t._v("接上面的代码：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//ColorPoint {}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h2",{attrs:{id:"原生构造函数的继承-原生构造函数的继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生构造函数的继承-原生构造函数的继承"}},[t._v("#")]),t._v(" 原生构造函数的继承 {#原生构造函数的继承}")]),t._v(" "),a("p",[t._v("原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。")]),t._v(" "),a("ul",[a("li",[t._v("Boolean()")]),t._v(" "),a("li",[t._v("Number()")]),t._v(" "),a("li",[t._v("String()")]),t._v(" "),a("li",[t._v("Array()")]),t._v(" "),a("li",[t._v("Date()")]),t._v(" "),a("li",[t._v("Function()")]),t._v(" "),a("li",[t._v("RegExp()")]),t._v(" "),a("li",[t._v("Error()")]),t._v(" "),a("li",[t._v("Object()")])]),t._v(" "),a("p",[t._v("以前，这些原生构造函数是无法继承的，比如，不能自己定义一个"),a("code",[t._v("Array")]),t._v("的子类。")]),t._v(" "),a("p",[t._v("ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象"),a("code",[t._v("this")]),t._v("，然后再用子类的构造函数修饰"),a("code",[t._v("this")]),t._v("，使得父类的所有行为都可以继承。下面是一个继承"),a("code",[t._v("Array")]),t._v("的例子。")]),t._v(" "),a("p",[t._v("上面代码定义了一个"),a("code",[t._v("MyArray")]),t._v("类，继承了"),a("code",[t._v("Array")]),t._v("构造函数，因此就可以从"),a("code",[t._v("MyArray")]),t._v("生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。")]),t._v(" "),a("p",[t._v("上面这个例子也说明，"),a("code",[t._v("extends")]),t._v("关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。")]),t._v(" "),a("h2",{attrs:{id:"class的取值函数（getter）和存值函数（setter）-class的取值函数（getter）和存值函数（setter）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class的取值函数（getter）和存值函数（setter）-class的取值函数（getter）和存值函数（setter）"}},[t._v("#")]),t._v(" Class的取值函数（getter）和存值函数（setter） {#Class的取值函数（getter）和存值函数（setter）}")]),t._v(" "),a("p",[t._v("与ES5一样，在Class内部可以使用"),a("code",[t._v("get")]),t._v("和"),a("code",[t._v("set")]),t._v("关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。")]),t._v(" "),a("h2",{attrs:{id:"class-的-generator-方法-class-的-generator-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-的-generator-方法-class-的-generator-方法"}},[t._v("#")]),t._v(" Class 的 Generator 方法 {#Class-的-Generator-方法}")]),t._v(" "),a("p",[t._v("如果某个方法之前加上星号（"),a("code",[t._v("*")]),t._v("），就表示该方法是一个 Generator 函数。")]),t._v(" "),a("h2",{attrs:{id:"class-的静态方法-class-的静态方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-的静态方法-class-的静态方法"}},[t._v("#")]),t._v(" Class 的静态方法 {#Class-的静态方法}")]),t._v(" "),a("p",[t._v("类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上"),a("code",[t._v("static")]),t._v("关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。")]),t._v(" "),a("h2",{attrs:{id:"class的静态属性和实例属性-class的静态属性和实例属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class的静态属性和实例属性-class的静态属性和实例属性"}},[t._v("#")]),t._v(" Class的静态属性和实例属性 {#Class的静态属性和实例属性}")]),t._v(" "),a("p",[t._v("静态属性指的是Class本身的属性，即"),a("code",[t._v("Class.propname")]),t._v("，而不是定义在实例对象（"),a("code",[t._v("this")]),t._v("）上的属性")]),t._v(" "),a("h2",{attrs:{id:"类的私有属性-类的私有属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的私有属性-类的私有属性"}},[t._v("#")]),t._v(" 类的私有属性 {#类的私有属性}")]),t._v(" "),a("p",[t._v("目前，有一个"),a("a",{attrs:{href:"https://github.com/tc39/proposal-private-fields",target:"_blank",rel:"noopener noreferrer"}},[t._v("提案"),a("OutboundLink")],1),t._v("，为"),a("code",[t._v("class")]),t._v("加了私有属性。方法是在属性名之前，使用"),a("code",[t._v("#")]),t._v("表示。")]),t._v(" "),a("h2",{attrs:{id:"new-target属性-new-target属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-target属性-new-target属性"}},[t._v("#")]),t._v(" new.target属性 {#new-target属性}")]),t._v(" "),a("p",[a("code",[t._v("new")]),t._v("是从构造函数生成实例的命令。ES6为"),a("code",[t._v("new")]),t._v("命令引入了一个"),a("code",[t._v("new.target")]),t._v("属性，（在构造函数中）返回"),a("code",[t._v("new")]),t._v("命令作用于的那个构造函数。如果构造函数不是通过"),a("code",[t._v("new")]),t._v("命令调用的，"),a("code",[t._v("new.target")]),t._v("会返回"),a("code",[t._v("undefined")]),t._v("，因此这个属性可以用来确定构造函数是怎么调用的。")]),t._v(" "),a("h2",{attrs:{id:"mixin模式的实现-mixin模式的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mixin模式的实现-mixin模式的实现"}},[t._v("#")]),t._v(" Mixin模式的实现 {#Mixin模式的实现}")]),t._v(" "),a("p",[t._v("Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。")])])}),[],!1,null,null,null);s.default=r.exports}}]);