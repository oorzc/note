(window.webpackJsonp=window.webpackJsonp||[]).push([[207],{764:function(v,_,e){"use strict";e.r(_);var p=e(5),t=Object(p.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[v._v("#")]),v._v(" 缓存")]),v._v(" "),e("h2",{attrs:{id:"缓存的使用方式、场景（原文copy的）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存的使用方式、场景（原文copy的）"}},[v._v("#")]),v._v(" 缓存的使用方式、场景（原文copy的）")]),v._v(" "),e("p",[v._v("为什么使用缓存")]),v._v(" "),e("p",[v._v("提升性能：使用缓存可以跳过数据库查询，分布式系统中可以跳过多次网络开销。在读多写少的场景下，可以有效的提高性能，降低数据库等系统的压力。")]),v._v(" "),e("p",[v._v("缓存的适用场景")]),v._v(" "),e("p",[v._v("1.数据不需要强一致性")]),v._v(" "),e("p",[v._v("2.读多写少，并且读取得数据重复性较高")]),v._v(" "),e("p",[v._v("缓存的正确打开方式")]),v._v(" "),e("p",[v._v("1.Cache Aside 同时更新缓存和数据库")]),v._v(" "),e("p",[v._v("2.Read/Write Through 先更新缓存，缓存负责同步更新数据库")]),v._v(" "),e("p",[v._v("3.Write Behind Caching 先更新缓存，缓存负责异步更新数据库")]),v._v(" "),e("p",[v._v("下面具体分析每种模式")]),v._v(" "),e("p",[v._v("一、Cache Aside 更新模式")]),v._v(" "),e("p",[v._v("这是最常用的缓存模式了，具体的流程是：")]),v._v(" "),e("p",[v._v("读取：应用程序先从 cache 取数据，取到后成功返回；没有得到，则从数据库中取数据，成功后，放到缓存中。")]),v._v(" "),e("p",[v._v("更新：先把数据存到数据库中，再清理缓存使其失效。")]),v._v(" "),e("p"),v._v(" "),e("p",[v._v("不过这种模式有几个变种：")]),v._v(" "),e("p",[v._v("第一，如果先更新数据库再更新缓存。假设两个并发更新操作，数据库先更新的反而后更新缓存，数据库后更新的反而先更新缓存。这样就会造成数据库和缓存中的数据不一致，应用程序中读取的都是脏数据。")]),v._v(" "),e("p",[v._v("第二，先删除缓存再更新数据库。假设一个更新操作先删除了缓存，一个读操作没有命中缓存，从数据库中取出数据并且更新回缓存，再然后更新操作完成数据库更新。这时数据库和缓存中的数据是不一致的，应用程序中读取的都是原来的数据。")]),v._v(" "),e("p",[v._v("第三，先更新数据库再删除缓存。假设一个读操作没有命中缓存，然后读取数据库的老数据。同时有一个并发更新操作，在读操作之后更新了数据库并清空了缓存。此时读操作将之前从数据库中读取出的老数据更新回了缓存。这时数据库和缓存中的数据也是不一致的。")]),v._v(" "),e("p",[v._v("但是一般情况下，缓存用于读多写少的场景，所以第三种这种情况其实是小概率会出现的。")]),v._v(" "),e("p",[v._v("二、Read/Write Through 更新模式")]),v._v(" "),e("p",[v._v("Read Through 模式就是在查询操作中更新缓存，缓存服务自己来加载。")]),v._v(" "),e("p",[v._v("Write Through 模式和 Read Through 相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由缓存自己更新数据库（这是一个同步操作）。")]),v._v(" "),e("p"),v._v(" "),e("p",[v._v("三、Write Behind Caching 更新模式")]),v._v(" "),e("p",[v._v("Write Behind Caching 更新模式就是在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。但其带来的问题是，数据不是强一致性的，而且可能会丢失。")]),v._v(" "),e("p"),v._v(" "),e("p",[v._v("总结，三种缓存模式的优缺点：")]),v._v(" "),e("p",[v._v("Cache Aside 更新模式实现起来比较简单，最常用，实时性也高，但是需要应用需要关注核实加载数据进入缓存 。")]),v._v(" "),e("p",[v._v("Read/Write Through 更新模式只需要维护一个缓存，对应用屏蔽掉了缓存的细节，实时性也高。但是实现起来要复杂一些。")]),v._v(" "),e("p",[v._v("Write Behind Caching 吞吐量很高，多次操作可以合并。但是数据可能会丢失，例如系统断电等，实现起来最复杂。")])])}),[],!1,null,null,null);_.default=t.exports}}]);