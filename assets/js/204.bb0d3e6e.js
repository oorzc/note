(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{773:function(_,t,v){"use strict";v.r(t);var e=v(5),r=Object(e.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"面向对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[_._v("#")]),_._v(" 面向对象")]),_._v(" "),v("p",[_._v("oop是什么?")]),_._v(" "),v("p",[_._v("oop是面向对象编程,面向对象编程是一种计算机编程架构,OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。")]),_._v(" "),v("p",[_._v("OOP具有三大特点")]),_._v(" "),v("p",[_._v("1、封装性：也称为信息隐藏，就是将一个类的使用和实现分开，只保留部分接口和方法与外部联系，或者说只公开了一些供开发人员使用的方法。于是开发人员只 需要关注这个类如何使用，而不用去关心其具体的实现过程，这样就能实现MVC分工合作，也能有效避免程序间相互依赖，实现代码模块间松藕合。"),v("br"),_._v("\n2、继承性：就是子类自动继承其父级类中的属性和方法，并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性。PHP只支持单继承，也就是说一个子类只能有一个父类。"),v("br"),_._v("\n3、多态性：子类继承了来自父级类中的属性和方法，并对其中部分方法进行重写。于是多个子类中虽然都具有同一个方法，但是这些子类实例化的对象调用这些相同的方法后却可以获得完全不同的结果，这种技术就是多态性。多态性增强了软件的灵活性。")]),_._v(" "),v("p",[_._v("1、易维护"),v("br"),_._v("\n采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的。"),v("br"),_._v("\n2、质量高"),v("br"),_._v("\n在设计时，可重用现有的，在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。"),v("br"),_._v("\n3、效率高"),v("br"),_._v("\n在软件开发时，根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。"),v("br"),_._v("\n4、易扩展"),v("br"),_._v("\n由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。")]),_._v(" "),v("h2",{attrs:{id:"php魔术方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#php魔术方法"}},[_._v("#")]),_._v(" PHP魔术方法")]),_._v(" "),v("p",[_._v("__construct()构造函数是目前为止经常使用的函数。在创建对象时，可以在构造函数中做 一些初始化工作。可以为构造函数定义任意多个参数，只要在实例化时传入对应个数的参数 即可。构造函数中出现的任何异常都会阻止对象的创建。")]),_._v(" "),v("p",[_._v("__desctruct()"),v("br"),_._v("\n析构函数通常在对象被销毁时调用，析构函数不接收任何参数。经常在析构函数 中执行一些清理工作，比如关闭数据库连接等。")]),_._v(" "),v("p",[_._v("__get()在我们尝试访问一个不存在的属性时会被调用。它接收一个参数，该参数表 示访问属性的名字，并且将该属性的值返回。")]),_._v(" "),v("p",[_._v("__set()魔术方法在我们尝试修改一个不可访问的属性时会被调用，它接收两个参数，一个表 示属性的名字，一个表示属性的值。")]),_._v(" "),v("p",[_._v("__isset()魔术方法在对一个不可访问的属性调用isset()方法时会被调用，它接收一个参数， 表示属性的名字。它应该返回一个布尔值，用来表示该属性是否存在。")]),_._v(" "),v("p",[_._v("__unset()魔术方法在调用 unset()函数销毁一个不能访问的属性时会被调用，它接收一个参数， 表述属性的名字。")]),_._v(" "),v("p",[_._v("__toString()在我们将对象当作字符串一样使用时会被调用，它不接收任何参数。该方法允许 我们定义对象的表现形式。 __clone()魔术方法__clone()可以解决上面的问题。当对一个对象使用 clone 关键字时，该魔 术方法会被调用。")]),_._v(" "),v("p",[_._v("__sleep()"),v("br"),_._v("\n魔术方法__sleep()在对一个对象序列化时(调用 serialize())会被调用。它不 接收任何参数，而且应该返回一个包含所有应该被序列化的属性的数组。在该魔 术方法中，也可以执行一些其他操作。 有一点要注意的是，不要再该函数中进行任何的析构操作，因为这可能会影响正 在运行的对象。")]),_._v(" "),v("p",[_._v("__wakeup()在对存储的对象反序列化时会被调用。它不接收任何参数，也没有任何 返回值。可以用它来处理在序列化时丢失的数据库连接或资源。")]),_._v(" "),v("p",[_._v("魔术方法__call()在调用不存在或不可访问的方法时会被调用。它接收两个参数，一个是调用 的方法的名字，一个是包含函数参数的数组。我们可以使用这种方法调用子对象中得同名函 数。")]),_._v(" "),v("h2",{attrs:{id:"private、protected、public、final-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#private、protected、public、final-区别"}},[_._v("#")]),_._v(" private、protected、public、final 区别")]),_._v(" "),v("p",[_._v("public:权限是最大的，可以内部调用，实例调用等。")]),_._v(" "),v("p",[_._v("protected: 受保护类型，用于本类和继承此类的子类调用。")]),_._v(" "),v("p",[_._v("private: 私有类型，只有在本类中使用。")]),_._v(" "),v("p",[_._v("static：静态资源，可以被子类继承。")]),_._v(" "),v("p",[_._v("abstract：修饰抽象方法，没有方法体，由继承该类的子类来实现。")]),_._v(" "),v("p",[_._v("final：表示该变量、该方法已经“完成”，不可被覆盖。修饰类时该类不能被继承。")]),_._v(" "),v("p",[_._v("（因此final和abstract不能同时出现）")])])}),[],!1,null,null,null);t.default=r.exports}}]);